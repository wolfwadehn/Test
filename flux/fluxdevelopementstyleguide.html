<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Encode+Sans+Semi+Condensed:wght@400;600&family=Nunito+Sans:ital,wght@0,400;0,600;1,400;1,600&family=Roboto+Mono:ital,wght@0,400;0,600;1,400;1,600&display=block" rel="stylesheet">
  <link rel="stylesheet" href="../res/bento.css">
  <link rel="stylesheet" href="../res/site.css">
  <link rel="stylesheet" href="../res/tree.css">
  <link rel="stylesheet" href="../res/sibling.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <title>Flux Development Style Guide</title>
</head>
<body id="site-body" onload="sLoaded()">
    <header id="site-header">
        <div id="header-logo"><img src="../img/logo.png" width="207" height="34" /></div>
        <div><p>Metamation Developer Notes</p></div>
    </header>
    <div id="site-main">
        <nav id="site-nav">
            <div class="treesite">
  <ul>
    <li><button class="tree blank"></button><a href="../index.html">Developer Notes</a></li>
    <li><button class="tree blank"></button><a href="../resourcemap.html">Resource Map</a></li>
    <li>
      <button class="tree closed"></button>
      <a href="../tools/index.html">Tools</a>
      <ul class="hide">
        <li><button class="tree blank"></button><a href="../tools/codeformatting.html">Code Formatting</a></li>
        <li><button class="tree blank"></button><a href="../tools/configuregit.html">Configuring Git</a></li>
        <li><button class="tree blank"></button><a href="../tools/assignments.html">Assignments</a></li>
        <li><button class="tree blank"></button><a href="../tools/testsandbox.html">Testing with Windows Sandbox</a></li>
        <li><button class="tree blank"></button><a href="../tools/singlefileapps.html">Single Binary Applications</a></li>
        <li><button class="tree blank"></button><a href="../tools/selfupdate.html">Self-Updating Applications</a></li>
      </ul>
    </li>
    <li>
      <button class="tree open"></button>
      <a href="index.html">Flux Guidelines</a>
      <ul>
        <li><button class="tree blank"></button><a href="fluxgitworkflow.html">Flux Git Workflow</a></li>
        <li><button class="tree blank"></button><a class="active" href="fluxdevelopementstyleguide.html">Flux Development Style Guide</a></li>
        <li><button class="tree blank"></button><a href="releasenotes.html">Release notes for Flux</a></li>
        <li><button class="tree blank"></button><a href="sonarcloud.html">SonarCloud analysis for Flux</a></li>
        <li><button class="tree blank"></button><a href="usingfluxsdk.html">Build a Flux SDK Program</a></li>
      </ul>
    </li>
    <li>
      <button class="tree closed"></button>
      <a href="../technotes/index.html">Technical Notes</a>
      <ul class="hide">
        <li><button class="tree blank"></button><a href="../technotes/machineids.html">Machine ID Scheme</a></li>
        <li><button class="tree blank"></button><a href="../technotes/xlate.html">Translation tables</a></li>
        <li><button class="tree blank"></button><a href="../technotes/createbendmc.html">Creating bend machines</a></li>
        <li><button class="tree blank"></button><a href="../technotes/importbendmc.html">Importing bend machines</a></li>
        <li><button class="tree blank"></button><a href="../technotes/importbendtools.html">Importing bend tools</a></li>
        <li><button class="tree blank"></button><a href="../technotes/importcomponents.html">Importing bend and cell components</a></li>
        <li><button class="tree blank"></button><a href="../technotes/flux-metacaminterface.html">Flux-MetaCAM interface</a></li>
        <li><button class="tree blank"></button><a href="../technotes/virtualdrives.html">Virtual drives</a></li>
        <li><button class="tree blank"></button><a href="../technotes/toolarvfields.html">ARV fields used in tool import</a></li>
      </ul>
    </li>
    <li>
      <button class="tree closed"></button>
      <a href="../doku/index.html">Documentation</a>
      <ul class="hide">
        <li><button class="tree blank"></button><a href="../doku/bento.html">Documentation using Bento</a></li>
        <li><button class="tree blank"></button><a href="../doku/deltatranslation.html">Delta translations</a></li>
        <li><button class="tree blank"></button><a href="../doku/languages.html">Languages</a></li>
        <li><button class="tree blank"></button><a href="../doku/flavoring.html">Changing to a flavor</a></li>
        <li><button class="tree blank"></button><a href="../doku/citations.html">Citations</a></li>
      </ul>
    </li>
  </ul>
</div>

        </nav>
        <div id="site-nav-right">
            <nav id="site-crumb">
  <div>
    <button>
      <img src="../res/home.png">
    </button>
  </div>
  <div>
    <a href="index.html">Flux Guidelines</a>
  </div>
  <div>/</div>
  <div>
    <a href="fluxdevelopementstyleguide.html">Flux Development Style Guide</a>
  </div>
</nav>

            <div id="site-crumb-below">
                <div id="site-toc-left">
                    <article id="article">
                        <h1>Flux Development Style Guide</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This document explains the style guidelines for Flux development. It covers the naming conventions and commenting conventions for Flux code.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_file_class_headers">File &amp; Class Headers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Insert something like the following header at the start of every file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// ---------------------------------------------------------------------------------------
// Flux ~ Sheet metal CAD/CAM system
// Copyright (c) Metamation India.                                                === --
// ---------------------------------------------------------------------------      ==( )
// Part.cs                                                                        === --
// Implements the Part class, which is the generic unit of processing in
// Flux. A part may be a flat-sheet part, a bending part, a 5-axis laser part,
// a welding part (or many of these at the same time).
// ---------------------------------------------------------------------------------------</pre>
</div>
</div>
<div class="paragraph">
<p>This header is from <strong>Flux.Core.dll</strong>, the other DLLs have a slightly different first line.
Each top-level class in a file has a header like this, where the divider extends to column 100 (with the
region open). The region header contains just two words like <strong>class Something</strong> or <strong>interface AnotherThing</strong> or
<strong>enum YetAnother</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>namespace Flux;
#region class Part --------------------------------------------------------------------------------
/// &lt;summary&gt;Summary for class Part&lt;/summary&gt;
/// More detailed documentation for class Part (a few lines, to a page or two even)
public class Part {
... many lines ...
}
#endregion</pre>
</div>
</div>
<div class="paragraph">
<p>The class itself is divided into several segments and each segment has a header like this, extending to
column 70.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public class Part {
   #region Properties -----------------------------------------------
   ...properties ...
   #endregion

   #region Methods --------------------------------------------------
   ... methods ...
   #endregion
}</pre>
</div>
</div>
<div class="paragraph">
<p><a href="#class_segments">Class Segments</a> section below explains the possible segments in a class</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_usings">Usings</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The user defined namespaces should be added after all the system namespaces being used in a particular file.</p>
</div>
<div class="paragraph">
<p>For eg: Flux namespaces should come after the system namespaces as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">using System.Windows;
using System.Windows.Controls;
using Flux.API.Bend;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="class_segments">Class Segments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The members of a class are organized into one or more segments. The order in which these segments are
listed below is the preferred ordering of segments, and we explain here what should go into each
segment.</p>
</div>
<div class="sect2">
<h3 id="_constructors">Constructors</h3>
<div class="paragraph">
<p>Public<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> or protected constructors go here; private constructors go into the Implementation section. Static
constructors should be private, and therefore should be in the implementation section. If there are static
factory methods that create objects, then those should appear here in the Constructors section. For
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>class Pline {
   #region Constructors ---------------------------------------------
   /// &lt;summary&gt;Construct a Circle polyline, given the center and radius&lt;/summary&gt;
   static Pline MakeCircle (Point2 center, double radius) {
   ... code ...
   }
   #endregion
}</pre>
</div>
</div>
<div class="paragraph">
<p>Note that this appears in the constructors section only if this is static, and the return type is the enclosing
class itself. In other words, it is effectively a constructor. The constructors are ordered in increasing
complexity of parameter lists<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_properties">Properties</h3>
<div class="paragraph">
<p>The properties section lists all public properties, fields and events. We don&#8217;t distinguish between public
properties and public fields, and where there is no particular need to use a property, we would
recommend using a field instead. For example, consider this class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public struct Point2 {
   public double X { get =&gt; mX; private set =&gt; mX = value; }
   double mX;

   public double Y { get =&gt; mY; private set =&gt; mY = value; }
   double mY;
}</pre>
</div>
</div>
<div class="paragraph">
<p>This could safely be replaced by this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>public readonly struct Point2 {
   public readonly double X;
   public readonly double Y;
}</pre>
</div>
</div>
<div class="paragraph">
<p>If, for some reason, we find it necessary to make X and Y properties (maybe we want to enforce some
kind of range checking, or fire a property-changed event), this entails re-compilation of all the
downstream code using Point2. That&#8217;s OK; we have the luxury of enforcing such re-compilation. If you are in doubt, consult senior programmer before using fields.</p>
</div>
<div class="paragraph">
<p>Properties are ordered alphabetically.</p>
</div>
</div>
<div class="sect2">
<h3 id="_methods">Methods</h3>
<div class="paragraph">
<p>This lists all the public or protected methods of the type. Private methods go into the implementation
section.</p>
</div>
<div class="paragraph">
<p>Overrides are treated in a special manner. If the root method of an override is part of Flux, then the
method belongs here. For example, <strong>GridPunch.GenCode()</strong> method is listed here (since it implements
<strong>ToolingItem.GenCode()</strong>, which is declared in Flux). On the other hand, <strong>GridPunch.ToString()</strong> method
appears in the implementation section, since it overrides the <strong>Object.ToString()</strong> methods, which is declared
outside Flux.</p>
</div>
<div class="paragraph">
<p>In some situations (as in implementing containers, or in WPF controls) one overrides a number of methods
from a particular base class or interface. When doing this, it is a good idea to have a separate section titled
something like <strong>UserControl implementation</strong> or <strong>IList implementation</strong>. Don&#8217;t do this if there are just one or
two methods being overridden.</p>
</div>
<div class="paragraph">
<p>Methods appear in alphabetical order; methods with the same name are sorted in increasing order of
parameter complexity.</p>
</div>
</div>
<div class="sect2">
<h3 id="_operators">Operators</h3>
<div class="paragraph">
<p>This lists all public or protected type conversion operators, binary and unary operators. Private operators
are moved into the implementation section<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_implementation">Implementation</h3>
<div class="paragraph">
<p>This list all the private methods, as well as the overrides that got shunted here from the methods section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nested_types">Nested types</h3>
<div class="paragraph">
<p>This lists all the nested types (including enumerations) that are declared within this class. Public types first,
private types next. Types are listed in alphabetical order.</p>
</div>
</div>
<div class="sect2">
<h3 id="_private_data">Private data</h3>
<div class="paragraph">
<p>This lists private fields and properties. All instance fields come first, followed by all static fields. Within
these sections they are listed in alphabetical order. There are some exceptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A field or private property that is used only in one method (for example, some kind of cache) can
be placed immediately after that method.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>public Rect2 GetBound () {
   if (mBound.IsEmpty) { ... compute bound ... }
   return mBound;
}
Rect2 mBound; // Place this here, rather than in the private data section</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A field that is used as a backing field for a property is placed immediately after that property:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>public double Area {
   get =&gt; mArea;
   set { mArea = value; PropertyChanged.Fire ("Area"); }
}
double mArea; // Place this here, rather than in the Private data section</pre>
</div>
</div>
<div class="paragraph">
<p>Follow this rule in general. Extending this, one could infer that static data that is used only in one static
constructor should appear immediately after that static constructor.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_naming_conventions">Naming Conventions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Class names: <strong>PlineIntersector</strong></p>
</div>
<div class="paragraph">
<p>Methods: <strong>GetExtendedBounds (&#8230;&#8203;)</strong></p>
</div>
<div class="paragraph">
<p>Public fields &amp; properties: <strong>MinHeight</strong></p>
</div>
<div class="paragraph">
<p>Private instance fields &amp; properties: <strong>mExtending</strong></p>
</div>
<div class="paragraph">
<p>Private static fields and properties: <strong>sCharMap</strong></p>
</div>
<div class="paragraph">
<p>Enumeration types: <strong>EClampType</strong>, <strong>ECorner</strong>, <strong>ECharacterSet</strong></p>
</div>
<div class="paragraph">
<p>Interface types: <strong>IDisplayDevice</strong>, <strong>ICurlable</strong>, <strong>IFormattable</strong></p>
</div>
<div class="paragraph">
<p>Use an <strong>m</strong> prefix for instance fields, and an <strong>s</strong> prefix for static fields, but no other type-specific (Hungarian)
prefixes<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_coding_conventions">Coding Conventions</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Use a stable (global) path for Flux.API</strong></p>
<div class="paragraph">
<p>Using a relative path will make it difficult for somebody who pulls your project to compile it. Also, it is best to checkout project files into a location closer to some drive root, rather than to your user-specific folders. So clone FChassis repo to W:/FChassis (where W: is work drive, created by "SUBST W: C:\Work")</p>
</div>
</li>
<li>
<p><strong>Update .gitignore to ignore folders with temporary artifacts</strong>#</p>
<div class="paragraph">
<p>Sometimes temporary files will be created which need not be in repo. For example say intermediate code files are generated in Sample/Head1 and Sample/Head2 folders. These should be added to .gitignore, so they don&#8217;t keep showing up as 'Untracked files'. Even worse, we may forget and add the contents of these folders to the repository.</p>
</div>
</li>
<li>
<p><strong>Don&#8217;t use the "private" keyword</strong></p>
<div class="paragraph">
<p>Private is the default access specifier in most cases (except for interfaces). So we rarely use it, if ever, need to specify the 'private' keyword in front of any field, property or method.</p>
</div>
</li>
<li>
<p><strong>Remove unnecessary usings</strong></p>
<div class="paragraph">
<p>Very often, when you create a new CS file, Visual Studio will helpfully add a bunch of using statements at the top. Before you commit, remove the ones that are not actually being used to reduce clutter. You can right click on one of these and execute the cleanup action (you can do this for the entire solution or project in one go).</p>
</div>
</li>
<li>
<p><strong>Use expression-bodies for trivial properties</strong><a id="expression-bodies"></a></p>
<div class="paragraph">
<p>Trivial properties that consist of a single expression should be replaced by a single expression body (reduce clutter).</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public Point3 StartPoint { get { return mStartPoint; } }</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public Point3 StartPoint =&gt; mStartPoint;</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Use the [] notation to create collection-expressions succinctly</strong><a id="collection-expressions"></a></p>
<div class="paragraph">
<p>The creation of a new empty collection can be written very simply using the 'empty collection expression'.</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">HashSet&lt;int&gt; mHashProgNo = new HashSet&lt;int&gt; ();</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">HashSet&lt;int&gt; mHashProgNo = [];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even if the collection is initialized with some elements, you can use this to simplify the code (both the statements below compile into exactly the same code).</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">mPriority = new List&lt;EKind&gt; { EKind.Hole, EKind.Cutout, EKind.Notch, EKind.Mark };</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">mPriority = [EKind.Hole, EKind.Cutout, EKind.Notch, EKind.Mark];</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Prefer file-scoped namespaces</strong></p>
<div class="paragraph">
<p>When all the contents of a file are contained in one namespace (the usual case), prefer a file scoped namespace - this reduces one level of indent for all the code in the file, and makes it more readable.</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">namespace FChassis {
  public partial class SettingsDialogHostWindow : Window {
     ...
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">namespace FChassis;

public partial class SettingsDialogHostWindow : Window {
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the empty line after namespace FChassis - this is a whitespace convention we follow.</p>
</div>
</li>
<li>
<p><strong>Use expression-bodies where possible (extension of <a href="#expression-bodies">[expression-bodies]</a>)</strong></p>
<div class="paragraph">
<p>Not just property getters, but property setters, methods, constructors, operators can all be rewritten as a single expression. This reduces clutter of open and close braces, and often converts 3 lines of code into one.</p>
</div>
<div class="paragraph">
<p><strong>Constructors.</strong></p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public GCodeGenerator (Process process) {
   mProcess = process;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public GCodeGenerator (Process process) =&gt; mProcess = process;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Method bodies.</strong></p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public static double D2R (this double degrees) {
   return degrees * (Math.PI / 180);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public static double D2R (this double degrees) =&gt; degrees * Math.PI / 180;</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Getters and Setters.</strong></p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public double this[int i, int j] {
   get { return A[i, j]; }
   set { A[i, j] = value; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public double this[int i, int j] { get =&gt; A[i, j]; set =&gt; A[i, j] = value; }</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Operators.</strong></p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public static XForm4 operator * (XForm4 a, XForm4 b) {
   return a.MultiplyNew (b);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public static XForm4 operator * (XForm4 a, XForm4 b) =&gt; a.MultiplyNew (b);</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Remove dead code before committing</strong></p>
<div class="paragraph">
<p>Git allows you to always go back to a previous version of code if you want to retrace your history. So there is no reason to keep dead code hanging around behind a comment. It creates a messy look for the code and promotes a 'broken window syndrome'. Remove dead code aggressively, and if some code needs to remain in for now, always mark it with a TODO comment like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs"> // TODO: Not sure if this alternative leads to better sequencing:
 // items = items.SortBy (a =&gt; a.Z).ThenBy (a =&gt; a.X).ToList ();</code></pre>
</div>
</div>
<div class="paragraph">
<p>That way, it is clear that you mean to come back to this code later and experiment with it.</p>
</div>
</li>
<li>
<p><strong>Remove empty documentation nodes before commit</strong></p>
<div class="paragraph">
<p>When you type in /// to create a documentation node, Visual Studio fills it with empty nodes for each of the parameters, return value, exceptions etc. If you are not actually documenting these, remove them.</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">/// &lt;summary&gt;
/// Get the ordinate direction sense for a vector
/// &lt;/summary&gt;
/// &lt;param name="toolingItem"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
/// &lt;exception cref="InvalidCastException"&gt;&lt;/exception&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">/// &lt;summary&gt;Get the ordinate direction sense for a vector&lt;/summary&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we are using the 'single line summary' Metamation convention.</p>
</div>
</li>
<li>
<p><strong>Don&#8217;t create lambda expressions unnecessarily</strong></p>
<div class="paragraph">
<p>Functions like Dispatcher.Invoke, Task.Run etc require objects of type Action&lt;T&gt; or just Action (with no parameters). If you already have a method that matches this signature, you can just directly pass it in - there is no need to create a wrapper lambda. So you can replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">Dispatcher.Invoke (() =&gt; {
   mOverlay.Redraw ();
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">Dispatcher.Invoke (mOverlay.Redraw);</code></pre>
</div>
</div>
</li>
<li>
<p><strong>You can often elide the type in a new() expression</strong></p>
<div class="paragraph">
<p>If the type of the object being created can be inferred (either because it is a parameter, or it is being assigned to a typed variable), then the type can be elided from a new expression.</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">XForm4 transMatrix = new XForm4 ();</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">var transMatrix = new ();</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative form of this (that is also acceptable) is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">var transMatrix = new XForm4 ();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works even if you need to pass parameters to the constructor.</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">Point3 prev = new Point3 (tooling.X, tooling.Y, mClearance);</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">Point3 prev = new (tooling.X, tooling.Y, mClearance);</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Use ?. to automate null checks</strong></p>
<div class="paragraph">
<p>The ?. operator can be used to call a method on an object only if it is not null. Thus, we can replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public void ClearDrawables () {
   if (mDrawables != null) mDrawables.Clear ();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public void ClearDrawables () =&gt; mDrawables?.Clear ();</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Replace 'as' and a null check with 'is'</strong></p>
<div class="paragraph">
<p>This code uses 'as' to try casting the Curve object to an Arc3, and then does some work if that is not null.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">Arc3 arc = segsList[0].Curve as Arc3;
if (arc != null) {
   if (arc.Start.EQ (arc.End))
      return true;
}
return false;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A simpler way is to to use an is operator that can do the check AND return a temporary of the cast type in one shot:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (segsList[0].Curve is Arc3 arc) {
   if (arc.Start.EQ (arc.End))
      return true;
}
return false;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In fact, this code above can then be cleaned up even further by merging the nested if:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (segsList[0].Curve is Arc3 arc &amp;&amp; arc.Start.EQ (arc.End)) return true;
return false;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even this can be simplified further. We are checking an expression (which is already a boolean) and returning true if that expression is true. So, we can simply write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">return segsList[0].Curve is Arc3 arc &amp;&amp; arc.Start.EQ (arc.End);</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Enumeration types always start with a capital E</strong></p>
<div class="paragraph">
<p>Enumeration types are always named with a capital E at the start. Likewise, interface types are always named with a capital I at the start. Also, since these are always <em>types</em>, do not use the Type suffix for the name.</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">enum MoveType { Arc, Line };</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">enum EMove { Arc, Line };</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Don&#8217;t repeat namespace prefixes in class names; avoid very long type names</strong></p>
<div class="paragraph">
<p>There is a readability issue with very long type names. Code like this is too verbose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">arcStartPoint = FChassisUtils.MovePoint (arcStartPoint, startNormal, FChassisMachineSettings.Instance.MachiningToolClearance);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here&#8217;s what is recommended:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">arcStart = Utils.MovePoint (arcStart, startNormal, MCSettings.It.Standoff);</code></pre>
</div>
</div>
<div class="paragraph">
<p>In particular, since we are working with the <strong>FChassis</strong> namespace, starting type names with <strong>FChassis</strong> is redundant.</p>
</div>
<div class="paragraph">
<p>Rename:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">FChassis.FChassisMachineSettings FChassis.FChassisUtils</code></pre>
</div>
</div>
<div class="paragraph">
<p>to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">FChassis.MCSettings FChassis.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rename such types to keep the names more compact, without losing legibility. Some of this is subjective, but code with very long identifiers for types, variables etc feels hard to understand.</p>
</div>
</li>
<li>
<p><strong>Avoid multiple blank lines in code</strong></p>
<div class="paragraph">
<p>There should never be two or more successive blank lines anywhere in the code.</p>
</div>
</li>
<li>
<p><strong>The canonical Singleton pattern</strong></p>
<div class="paragraph">
<p>Metamation convention: Use 'It' as the property by which we get at the singleton object (rather than Instance).</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">static MCSettings instance;
public static MCSettings Instance =&gt; instance ?? (instance = new MCSettings ());</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public static MCSettings It =&gt; mIt ??= new ();
static MCSettings mIt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how we use the ??= operator to conditionally assign to an object only if it is not null. Also, we use these conventions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Name fields with an m prefix</p>
</li>
<li>
<p>Place the private backing field of a property <em>after</em> the property, not before it</p>
<div class="paragraph">
<p>The code above is almost fine, but is not thread-safe. If you want to be absolutely rigorous about it, here is the correct, thread-safe, performant way that does not lock. (See System.Lazy for more documentation on that type)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public static MCSettings It =&gt; mLazy.Value;
static readonly Lazy&lt;MCSettings&gt; mLazy = new (() =&gt; new ());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The initialize for Lazy can be cryptic, here is the same code with type names for clarity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">static readonly Lazy&lt;MCSettings&gt; mLazy = new Lazy&lt;MCSettings&gt; (() =&gt; new MCSettings ());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Lazy&lt;T&gt; takes a delegate that can be called to construct a T on demand.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Pattern matching, instead of multiple == checks</strong></p>
<div class="paragraph">
<p>Code like this can be simplified:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">bool ShouldOutputInfo (Tooling item) =&gt; item.Kind == EKind.Hole || item.Kind == EKind.Mark;</code></pre>
</div>
</div>
<div class="paragraph">
<p>to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">bool ShouldOutputInfo (Tooling item) =&gt; item.Kind is EKind.Hole or EKind.Mark;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, this code can be further simplified from:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (MCSettings.It.ToolConfiguration == MCSettings.EHeads.Left ||
    MCSettings.It.ToolConfiguration == MCSettings.EHeads.Both)
       tooling.Head = 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (MCSettings.It.Heads is MCSettings.EHeads.Left or MCSettings.EHeads.Both)
   tooling.Head = 0;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, ToolConfiguration is renamed to Heads, since that is what it really is:</p>
</div>
<div class="paragraph">
<p>Heads = Left/Right/Both (it is less generic a name than ToolConfiguration).</p>
</div>
<div class="paragraph">
<p>Here is another simplification.</p>
</div>
<div class="paragraph">
<p>From:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (toolingItem.IsCutout ()) blockType =
   (Utils.GetFlange (Workpiece, toolingItem) == EFlange.Top ||
    Utils.GetFlange (Workpiece, toolingItem) == EFlange.Bottom ? -1 : 1) * 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (toolingItem.IsCutout ()) blockType =
   Utils.GetFlange (Workpiece, toolingItem) is EFlange.Top or EFlange.Bottom ? -3 : 3;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also pattern match on ranges.</p>
</div>
<div class="paragraph">
<p>From:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (thick &gt;= 3.5 &amp;&amp; thick &lt; 4.5) { webPageNo = 8; flangePageNo = 7; }
if (thick &gt;= 4.5 &amp;&amp; thick &lt; 5.5) { webPageNo = 10; flangePageNo = 9; }
if (thick &gt;= 6.5 &amp;&amp; thick &lt; 7.5) { webPageNo = 14; flangePageNo = 13; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (thick is &gt;= 3.5 and &lt; 4.5) { webPageNo = 8; flangePageNo = 7; }
if (thick is &gt;= 4.5 and &lt; 5.5) { webPageNo = 10; flangePageNo = 9; }
if (thick is &gt;= 6.5 and &lt; 7.5) { webPageNo = 14; flangePageNo = 13; }</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Use of the 'is not' pattern to simplify code</strong></p>
<div class="paragraph">
<p>This code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">while (targetItem != null &amp;&amp; !(targetItem is ListBoxItem)) {
   targetItem = VisualTreeHelper.GetParent (targetItem) as FrameworkElement;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be rewritten as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">while (targetItem is not null and not ListBoxItem)
   targetItem = VisualTreeHelper.GetParent (targetItem) as FrameworkElement;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note also the convention we follow that a single statement as the body of a for / while loop is not surrounded by braces.</p>
</div>
</li>
<li>
<p><strong>Using the ??= operator (compound assignment)</strong></p>
<div class="paragraph">
<p>Using the ??= operator can avoid the typical pattern of 'check if not null before assignment'.</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">E3Plane YNegPlane {
   get {
      if (mYNegPlane == null)
         mYNegPlane = Ents.OfType&lt;E3Plane&gt; ().Single (a =&gt; a.ThickVector.Z.EQ (1));
      return mYNegPlane;
   }
}
E3Plane mYNegPlane;</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">E3Plane YNegPlane {
   get {
      mYNegPlane ??= Ents.OfType&lt;E3Plane&gt; ().Single (a =&gt; a.ThickVector.Z.EQ (1));
      return mYNegPlane;
   }
}
E3Plane mYNegPlane;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In fact, this very common pattern can be simplified even further to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">E3Plane YNegPlane =&gt;
   mYNegPlane ??= Model.Ents.OfType&lt;E3Plane&gt; ().Single (a =&gt; a.ThickVector.Z.EQ (1));
E3Plane mYNegPlane;</code></pre>
</div>
</div>
</li>
<li>
<p><strong>More use of collection expressions [] (similar to <a href="#collection-expressions">[collection-expressions]</a>)</strong></p>
<div class="paragraph">
<p>Collection expressions are useful to replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">double[] mControlDiameter = new[] { 14.7 };</code></pre>
</div>
</div>
<div class="paragraph">
<p>with this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">double[] mControlDiameter = [14.7];</code></pre>
</div>
</div>
<div class="paragraph">
<p>They can also be used to create nested collections.</p>
</div>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">List&lt;List&lt;GCodeSeg&gt;&gt;&gt; mDrawable = new List&lt;List&lt;GCodeSeg&gt;&gt; () {
   new List&lt;GCodeSeg&gt; (), new List&lt;GCodeSeg&gt; ()
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">List&lt;GCodeSeg&gt;[] mDrawable = [[], []];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, in parameter lists. This code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">Lux.Draw (EDraw.Lines, new Point3[2] { pt, pt2 });</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be replaced with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">Lux.Draw (EDraw.Lines, [pt, pt2]);</code></pre>
</div>
</div>
</li>
<li>
<p><strong>Using the spread operator .. to build up lists</strong></p>
<div class="paragraph">
<p>When the spread operator (..) is used within a collection initializer, it effectively creates a list out of the contents of that collection. This works with Enumerable&lt;T&gt; as well. Here&#8217;s some old code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public List&lt;Tooling&gt; GetToolings4LHHead () {
   var toolingItems = Cuts.Where (a =&gt; a.Head == 0).ToList ();
   toolingItems = toolingItems.OrderBy (obj =&gt; Priority.IndexOf (obj.Kind)).ToList ();
   return toolingItems;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>that we can simplify to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">public List&lt;Tooling&gt; GetToolings4LHHead () =&gt;
   [.. Cuts.Where (a =&gt; a.Head == 0).OrderBy (a =&gt; Priority.IndexOf (a.Kind))];</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>We don&#8217;t need to capture the results of the filter (Where) into an intermediate list (in fact, that is inefficient). We can just pass that sequence directly to OrderBy, and make a list at the end.</p>
</li>
<li>
<p>Note how the .. at the start of the collection expression replaces the <em>sequence</em> we have with the actual elements of that sequence. Without that, this expression would be a list of exactly one IEnumerable&lt;T&gt;. With this .., the enumerable gets replaced with the actual enumerated elements, forming the correct list.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Don&#8217;t check with List.Contains before calling List.Remove</strong></p>
<div class="paragraph">
<p>This code is inefficient, since it will walk through the List twice (once for the Contains, once for the Remove).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (itemsSource.Contains (droppedData)) {
   itemsSource.Remove (droppedData);
   ... more code ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead, write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (itemsSource.Remove (droppedData)) {
   ... more code ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works, since Remove returns a bool (true if the item was found and removed).</p>
</div>
</li>
<li>
<p><strong>string.SubString can usually be replaced with a range operator</strong></p>
<div class="paragraph">
<p>Replace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (ncname.Length &gt; 20) ncname = ncname.Substring (0, 20);
string trimStart = ncname.SubString (5);</code></pre>
</div>
</div>
<div class="paragraph">
<p>with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C# hljs" data-lang="C#">if (ncname.Length &gt; 20) ncname = ncname[..20];
string trimStart = ncname[5..];</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. In this discussion, treat internal as public
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. We know this is rather vague; do your best.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. Not sure if one even needs private operators.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. There is a special variation of this m prefix rule. For classes that are designed to be serialized with the Au metadata system, field names that start with an underscore are implicitly treated as <em>cached</em> fields that are never serialized. This greatly simplifies writing the Metadata for that type; without this convention, one would have to list every such cached field and explicitly tag it as Cached so it does not get serialized.
</div>
</div>

                    </article>
                </div>
                <div id="site-toc-holder">
                    <aside id="site-toc">
  <h3>Contents</h3>
  <ul>
    <li level="1">
      <a href="#_file_class_headers">File &amp; Class Headers</a>
    </li>
    <li level="1">
      <a href="#_usings">Usings</a>
    </li>
    <li level="1">
      <a href="#class_segments">Class Segments</a>
    </li>
    <li level="2">
      <a href="#_constructors">Constructors</a>
    </li>
    <li level="2">
      <a href="#_properties">Properties</a>
    </li>
    <li level="2">
      <a href="#_methods">Methods</a>
    </li>
    <li level="2">
      <a href="#_operators">Operators</a>
    </li>
    <li level="2">
      <a href="#_implementation">Implementation</a>
    </li>
    <li level="2">
      <a href="#_nested_types">Nested types</a>
    </li>
    <li level="2">
      <a href="#_private_data">Private data</a>
    </li>
    <li level="1">
      <a href="#_naming_conventions">Naming Conventions</a>
    </li>
    <li level="1">
      <a href="#_coding_conventions">Coding Conventions</a>
    </li>
  </ul>
</aside>

                </div>
            </div>
            <nav class="pagination">
  <span class="prev"><a href="fluxgitworkflow.html">Flux Git Workflow</a></span>
  <span class="next"><a href="releasenotes.html">Release notes for Flux</a></span>
</nav>

        </div>
        <div id="searchbox">
          <input id="searchinput" type="search" placeholder="Search... (Key: F)" autocomplete="false" size="30" />
          <ul id="results"></ul>
        </div>
    </div>
    <footer id="site-footer">
        <div class="left">
            <p>&nbsp;&nbsp;Copyright &copy; 2023 by Metamation. All rights reserved.</p>
        </div>
        <div class="middle"></div>
        <div class="right">
            <p>Compiled by Bento</p>
            <img src="../res/bento.png" />
        </div>
    </footer>
    <script>
        // The baseLevel is used to assign the search result pages.
        var baseLevel = "../res".replace("res", "");
    </script>
    <script src="https://unpkg.com/lunr/lunr.js"></script>
    <script src="../res/index.js"></script>
    <script src="../res/files.js"></script>
    <script src="../res/site.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
  <script>
    if (!hljs.initHighlighting.called) {
      hljs.initHighlighting.called = true
      ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
    }
  </script>
</body>
</html>
